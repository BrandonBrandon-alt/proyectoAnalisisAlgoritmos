<!doctype html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Requerimiento 5 ‚Äî Resultados</title>
    <style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

:root {
  --primary: #7c3aed;
  --primary-dark: #6d28d9;
  --primary-light: #a78bfa;
  --secondary: #06b6d4;
  --background: #0f172a;
  --surface: #1e293b;
  --card: #334155;
  --text: #f1f5f9;
  --text-muted: #94a3b8;
  --accent: #f59e0b;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', system-ui, -apple-system, "Segoe UI", Roboto, Arial;
  background: var(--background);
  color: var(--text);
  min-height: 100vh;
  position: relative;
  overflow-x: hidden;
  padding: 20px;
}

body::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: 
    radial-gradient(circle at 20% 50%, rgba(124, 58, 237, 0.15) 0%, transparent 50%),
    radial-gradient(circle at 80% 80%, rgba(6, 182, 212, 0.15) 0%, transparent 50%);
  pointer-events: none;
  z-index: 0;
}

.wrap {
  max-width: 1400px;
  margin: 0 auto;
  position: relative;
  z-index: 1;
}

h1 {
  font-size: 2.5rem;
  font-weight: 700;
  margin-bottom: 12px;
  background: linear-gradient(135deg, var(--primary-light), var(--secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.lead {
  font-size: 1.1rem;
  color: var(--text-muted);
  margin-bottom: 32px;
  line-height: 1.6;
}

button {
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 10px;
  cursor: pointer;
  font-size: 0.95rem;
  font-weight: 600;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 4px 12px rgba(124, 58, 237, 0.3);
}

button:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(124, 58, 237, 0.5);
}

button:disabled {
  background: var(--card);
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.muted {
  color: var(--text-muted);
  font-size: 0.9rem;
}

.grid {
  display: grid;
  grid-template-columns: 1fr 1.5fr;
  gap: 24px;
  margin-top: 24px;
}

@media (max-width: 1024px) {
  .grid {
    grid-template-columns: 1fr;
  }
}

.card {
  background: var(--surface);
  border-radius: 16px;
  padding: 24px;
  border: 1px solid rgba(148, 163, 184, 0.1);
  transition: all 0.3s;
}

.card:hover {
  border-color: rgba(124, 58, 237, 0.3);
  box-shadow: 0 8px 24px rgba(124, 58, 237, 0.2);
}

.card strong {
  display: block;
  font-size: 1.25rem;
  font-weight: 600;
  margin-bottom: 16px;
  color: var(--text);
}

.status {
  padding: 16px;
  background: var(--card);
  border-radius: 10px;
  font-size: 0.95rem;
  border: 1px solid rgba(148, 163, 184, 0.1);
}

.preview {
  max-width: 100%;
  border-radius: 12px;
  border: 1px solid rgba(148, 163, 184, 0.2);
  margin-top: 12px;
  transition: transform 0.3s;
}

/* Prevent very large generated images from breaking the layout */
.preview {
    max-height: 560px; /* limit height */
    width: 100%;
    height: auto;
    object-fit: contain;
}

/* Ensure large generated images don't break the layout. Use responsive sizing
     and contain the image within a reasonable max-height. */
.preview {
    display: block;
    max-width: 100%;
    width: 100%;
    height: auto;
    max-height: 640px; /* limit extreme tall images */
    object-fit: contain;
}

.preview:hover {
  transform: scale(1.02);
}

.btn-link {
  display: inline-block;
  padding: 10px 20px;
  background: linear-gradient(135deg, #16a34a, #15803d);
  color: white;
  text-decoration: none;
  border-radius: 10px;
  font-size: 0.9rem;
  font-weight: 600;
  transition: all 0.3s;
  box-shadow: 0 4px 12px rgba(22, 163, 74, 0.3);
}

.btn-link:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(22, 163, 74, 0.5);
  background: linear-gradient(135deg, #15803d, #166534);
}

pre {
  background: var(--card);
  color: var(--text);
  padding: 16px;
  border-radius: 10px;
  overflow: auto;
  font-family: 'Courier New', monospace;
  font-size: 0.85rem;
  border: 1px solid rgba(148, 163, 184, 0.1);
  line-height: 1.5;
}

table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 12px;
}

th {
  background: var(--card);
  color: var(--text);
  padding: 12px;
  text-align: left;
  font-weight: 600;
  border-bottom: 2px solid var(--primary);
}

td {
  padding: 12px;
  border-bottom: 1px solid rgba(148, 163, 184, 0.1);
}

tr:hover {
  background: var(--card);
}

code {
  background: var(--card);
  padding: 4px 8px;
  border-radius: 6px;
  font-family: 'Courier New', monospace;
  font-size: 0.85rem;
  color: var(--primary-light);
}

.top-list table {
  margin-top: 0;
}
    </style>
</head>
<body>
<div class="wrap">
    <div style="margin-bottom: 24px;">
        <a href="../../index.html" style="display: inline-flex; align-items: center; gap: 8px; color: var(--text-muted); text-decoration: none; font-size: 0.9rem; transition: color 0.3s;">
            <span style="font-size: 1.2rem;">‚Üê</span> Volver al inicio
        </a>
    </div>
    
    <h1>Requerimiento 5 ‚Äî Visualizaciones y Reportes</h1>
    <p class="lead">Pulsa el bot√≥n para cargar los resultados generados por el notebook (archivos esperados en la carpeta del proyecto).</p>

    <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
        <button id="loadBtn">Cargar resultados</button>
        <button id="refreshBtn" style="background: linear-gradient(135deg, var(--secondary), #0891b2); box-shadow: 0 4px 12px rgba(6, 182, 212, 0.3);" disabled>üîÑ Actualizar visualizaciones</button>
        <span id="msg" class="muted" style="margin-left:12px"></span>
    </div>

    <!-- Upload and regenerate controls -->
    <div style="display:flex; gap:8px; align-items:center; margin-top:12px;">
        <input id="bibFile" type="file" accept=".bib" style="padding:6px; background:var(--card); color:var(--text); border-radius:8px;" />
        <button id="uploadBibBtn" style="background: linear-gradient(135deg, #f97316, #ef4444); box-shadow: 0 4px 10px rgba(239,68,68,0.2);">üì§ Subir .bib</button>
        <button id="runCloudBtn" style="background: linear-gradient(135deg, #06b6d4, #0891b2); box-shadow: 0 4px 10px rgba(6,182,212,0.2);">‚òÅÔ∏è Generar nube</button>
        <span id="uploadMsg" class="muted" style="margin-left:12px">Seleccione un archivo .bib y pulse ¬´Subir .bib¬ª</span>
    </div>
    
    <div id="updateInfo" style="margin-top: 16px; padding: 12px; background: var(--card); border-radius: 10px; border: 1px solid rgba(148, 163, 184, 0.1); display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px;">
            <div>
                <span class="muted">üìä √öltima actualizaci√≥n:</span>
                <strong id="lastUpdate" style="margin-left: 8px; color: var(--primary-light);">-</strong>
            </div>
            <div>
                <span class="muted">üìù Registros totales:</span>
                <strong id="totalRecords" style="margin-left: 8px; color: var(--secondary);">-</strong>
            </div>
            <div>
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                    <input type="checkbox" id="autoRefresh" style="cursor: pointer;">
                    <span class="muted">Auto-actualizar cada 30s</span>
                </label>
            </div>
        </div>
        <div style="margin-top:10px; font-size:0.9rem; color:var(--text-muted);">
            <span class="muted">Fuente de datos:</span>
            <code id="recordsSource" style="margin-left:8px; color:var(--primary-light);">-</code>
            <span id="recordsMeta" style="margin-left:12px; color:var(--text-muted);">-</span>
        </div>
    </div>

    <div class="grid">
        <div>
            <div id="summary" class="card">
                <strong>Resumen</strong>
                <div class="status" id="summaryText">No se ha cargado ning√∫n archivo todav√≠a.</div>
                <div id="counts" style="margin-top:8px"></div>
            </div>

            <div id="topCountriesCard" class="card" style="margin-top:12px; display:none;">
                <strong>Top pa√≠ses (primer autor)</strong>
                <div class="top-list" id="topCountries"></div>
            </div>

            
        </div>

        <div>
            <div class="card">
                <strong>Visualizaciones</strong>
                <div id="visuals" style="margin-top:8px">
                    <div id="mapContainer" style="margin-bottom:12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <div class="muted">Mapa de pa√≠ses (mapa_paises.png)</div>
                            <span id="mapTimestamp" class="muted" style="font-size: 0.8rem;"></span>
                        </div>
                        <img id="mapImg" class="preview" alt="Mapa de pa√≠ses" style="display:none" />
                        <div id="mapMsg" class="muted" style="margin-top:6px"></div>
                    </div>

                    <div id="cloudContainer" style="margin-bottom:12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <div class="muted">Nube de palabras (nube_palabras.png)</div>
                            <span id="cloudTimestamp" class="muted" style="font-size: 0.8rem;"></span>
                        </div>
                        <img id="cloudImg" class="preview" alt="Nube de palabras" style="display:none" />
                        <div id="cloudMsg" class="muted" style="margin-top:6px"></div>
                    </div>

                    <div id="timelineContainer" style="margin-bottom:12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <div class="muted">L√≠nea temporal (linea_tiempo_by_source.png)</div>
                            <span id="timelineTimestamp" class="muted" style="font-size: 0.8rem;"></span>
                        </div>
                        <img id="timelineImg" class="preview" alt="L√≠nea temporal" style="display:none" />
                        <div id="timelineMsg" class="muted" style="margin-top:6px"></div>
                        <div style="margin-top:6px;">
                            <a id="timelinePdfLink" class="btn-link" target="_blank" style="display:none">Abrir l√≠nea temporal (PDF)</a>
                        </div>
                    </div>

                    <div id="pdfContainer">
                        <div class="muted">Informe combinado (requerimiento5_report.pdf)</div>
                        <a id="reportLink" class="btn-link" target="_blank" style="display:none">Abrir informe (PDF)</a>
                        <div id="pdfMsg" class="muted" style="margin-top:6px"></div>
                    </div>
                </div>
            </div>

            <div class="card" style="margin-top:12px;">
                <strong>Logs</strong>
                <pre id="log" style="height:220px">Esperando acci√≥n...</pre>
            </div>
        </div>
    </div>

    <script>
    // Rutas relativas desde este archivo (requerimiento5/index.html)
    // Los archivos generados por el notebook se colocan en la carpeta `outputs/`
    // Direcci√≥n p√∫blica del backend (Render). Este valor se usa SOLO para las
    // llamadas de acci√≥n (POST): /api/upload_bib y /api/run_wordcloud.
    // Los ficheros est√°ticos como `data/` y `outputs/` se consideran locales y
    // se cargar√°n desde el mismo origen que sirve esta p√°gina (rutas relativas).
    const API_BACKEND = 'https://backend-proyecto-analisis-algoritmos.onrender.com';
    const apiBase = API_BACKEND || ((location.protocol && location.protocol.startsWith('http')) ? location.origin : '');
    // staticBase queda vac√≠o por defecto: las rutas relativas (p.ej. 'outputs/nube.png')
    // se resolver√°n desde el origen que sirva esta p√°gina.
    const staticBase = '';

        const paths = {
            records: 'data/records.csv',
            cache: 'data/country_lookup.csv',
            mapa: 'outputs/mapa_paises.png',
            nube: 'outputs/nube_palabras.png',
            timeline_png: 'outputs/linea_tiempo_by_source.png',
            timeline_pdf: 'outputs/linea_tiempo_by_source.pdf',
            report: 'outputs/requerimiento5_report.pdf'
        };

        function resolvePath(p){
            if(!p) return p;
            // absolute URL or already starting with / -> return as-is
            if(p.startsWith('http') || p.startsWith('/')) return p;
            // For static files (data/, outputs/) we keep relative paths so they
            // are requested from the same origin that serves this page.
            // This ensures `records.csv` and `country_lookup.csv` remain local.
            return staticBase ? (staticBase + p) : p;
        }

        const logEl = document.getElementById('log');
        function log(...args){ logEl.textContent = args.join(' ') + "\n\n" + logEl.textContent; }

        function showMsg(text){ document.getElementById('msg').textContent = text; }
        
        let autoRefreshInterval = null;
        let lastRecordCount = 0;
        let isLoaded = false;

        async function fetchText(path){
            // Append cache-buster so we don't get stale copies of records/frequencies
            let p = resolvePath(path);
            const ts = new Date().getTime();
            if(p.indexOf('?') === -1) p = p + '?t=' + ts; else p = p + '&t=' + ts;
            try{
                const res = await fetch(p);
                if(!res.ok) throw new Error('HTTP ' + res.status);
                return await res.text();
            } catch(e){
                throw new Error(`No disponible: ${p} (${e.message})`);
            }
        }

        function parseCSVSimple(text){
            // Parse CSV simple: as fallback splits by lines and commas.
            // No robust quoting support; suficiente para mostrar columnas principales.
            const lines = text.split(/\r?\n/).filter(l => l.trim() !== '');
            if(lines.length === 0) return {headers:[], rows:[]};
            const headers = lines[0].split(',').map(h => h.replace(/^"|"$/g,'').trim());
            const rows = lines.slice(1).map(line => {
                // naive split but keep quoted values together
                const values = [];
                let cur = '', inQ=false;
                for(let i=0;i<line.length;i++){
                    const ch = line[i];
                    if(ch === '"' ) { inQ = !inQ; continue; }
                    if(ch === ',' && !inQ){ values.push(cur); cur=''; continue; }
                    cur += ch;
                }
                values.push(cur);
                // pad to headers
                while(values.length < headers.length) values.push('');
                return headers.reduce((o,k,i)=>{ o[k]= (values[i]||'').trim(); return o; }, {});
            });
            return {headers, rows};
        }

    // Helper: update total records and lastUpdate from records.csv
        async function updateCountsFromRecords(){
            try{
                // Prefer backend records_total endpoint when available
                let total = null;
                let sourceName = null;
                if(API_BACKEND){
                    try{
                        const r = await fetch(API_BACKEND.replace(/\/$/, '') + '/api/records_total');
                        if(r.ok){
                            const j = await r.json();
                            if(j && typeof j.total_records === 'number'){
                                total = j.total_records;
                                sourceName = j.source || '';
                            }
                        }
                    }catch(e){
                        // ignore and fallback to local CSV
                    }
                }

                const resolved = resolvePath(paths.records);
                // If we have remote total, show the remote source
                if(total !== null){
                    document.getElementById('recordsSource').textContent = sourceName ? (sourceName + ' (remoto)') : (API_BACKEND + '/api/records_total');
                    document.getElementById('recordsMeta').textContent = '(obtenido desde backend remoto)';
                    document.getElementById('totalRecords').textContent = total;
                    lastRecordCount = total;
                    document.getElementById('updateInfo').style.display = 'block';
                    document.getElementById('lastUpdate').textContent = new Date().toLocaleString('es-ES');
                    log('Conteo (remoto) actualizado a', total);
                    return total;
                }

                // Fallback: read local records.csv
                document.getElementById('recordsSource').textContent = resolved;
                try{
                    const head = await fetch(resolved, { method: 'HEAD' });
                    if(head.ok){
                        const lm = head.headers.get('last-modified');
                        const cl = head.headers.get('content-length');
                        const metaParts = [];
                        if(lm) metaParts.push('mod: ' + new Date(lm).toLocaleString('es-ES'));
                        if(cl) metaParts.push('size: ' + (Math.round(Number(cl)/1024)) + ' KB');
                        document.getElementById('recordsMeta').textContent = metaParts.join(' | ');
                    } else {
                        document.getElementById('recordsMeta').textContent = '';
                    }
                }catch(e){ document.getElementById('recordsMeta').textContent = ''; }

                const recordsText = await fetchText(paths.records);
                const parsed = parseCSVSimple(recordsText);
                total = parsed.rows.length;
                document.getElementById('totalRecords').textContent = total;
                lastRecordCount = total;
                document.getElementById('updateInfo').style.display = 'block';
                document.getElementById('lastUpdate').textContent = new Date().toLocaleString('es-ES');
                log('Conteo actualizado a', total);
                return total;
            } catch(e){
                // if records not available, don't fail
                log('No se pudo leer records.csv para actualizar conteo:', e.message);
                return null;
            }
        }

        function topCounts(items, key, topN=10){
            const counts = {};
            items.forEach(it => {
                const k = (it[key] || '').trim();
                if(!k) return;
                counts[k] = (counts[k] || 0) + 1;
            });
            const arr = Object.entries(counts).sort((a,b)=>b[1]-a[1]).slice(0,topN);
            return arr;
        }

        // Use an <img> probe to check if an image URL exists.
        // This avoids CORS/preflight issues that appear when using fetch HEAD from browsers.
        async function checkImage(url){
            const p = resolvePath(url);
            return new Promise((resolve) => {
                try{
                    const img = new Image();
                    // Add cache-buster
                    const sep = p.indexOf('?') === -1 ? '?' : '&';
                    img.onload = function(){ resolve(true); };
                    img.onerror = function(){ resolve(false); };
                    img.src = p + sep + 't=' + (new Date().getTime());
                }catch(e){ resolve(false); }
            });
        }

        // If the backend exposes a direct image endpoint, prefer it for the cloud.
        function remoteCloudUrl(){
            // Prefer the explicit /api/image endpoint if available on the backend.
            if(API_BACKEND){
                return API_BACKEND.replace(/\/$/, '') + '/api/image';
            }
            return null;
        }

        // Probe a set of candidate remote URLs and return the first reachable one.
        async function findRemoteCloud(){
            if(!API_BACKEND) return null;
            const base = API_BACKEND.replace(/\/$/, '');
            const candidates = [
                base + '/api/image',
                base + '/outputs/nube_palabras.png',
                base + '/api/outputs/nube_palabras.png',
                base + '/image',
                base + '/outputs/nube_palabras.PNG'
            ];
            for(const c of candidates){
                try{
                    const ok = await checkImage(c);
                    if(ok) return c;
                }catch(e){
                    // ignore
                }
            }
            return null;
        }

        // Probe a named output file on the remote backend (e.g. timeline image)
        async function findRemoteOutput(name){
            if(!API_BACKEND) return null;
            const base = API_BACKEND.replace(/\/$/, '');
            const candidates = [
                base + '/outputs/' + name,
                base + '/api/outputs/' + name,
            ];
            for(const c of candidates){
                try{
                    const ok = await checkImage(c);
                    if(ok) return c;
                }catch(e){ }
            }
            return null;
        }

        document.getElementById('loadBtn').addEventListener('click', async function(){
            const btn = this;
            btn.disabled = true;
            showMsg('Cargando...');
            log('Inicio de carga de resultados');
            document.getElementById('summaryText').textContent = 'Cargando archivos...';
            try{
                // Fetch records.csv
                let recordsText=null;
                try{
                    recordsText = await fetchText(paths.records);
                    log('records.csv cargado:', paths.records);
                } catch(e){
                    log(e.message);
                }

                // Fetch country_lookup.csv
                let cacheText=null;
                try{
                    cacheText = await fetchText(paths.cache);
                    log('country_lookup.csv cargado:', paths.cache);
                } catch(e){
                    log(e.message);
                }

                // Try to show images and PDF (HEAD requests)
                const mapaOk = await checkImage(paths.mapa);
                const nubeOk = await checkImage(paths.nube);
                const timelineOk = await checkImage(paths.timeline_png);
                let reportOk = false;
                try {
                    const r = await fetch(resolvePath(paths.report), {method:'HEAD'});
                    reportOk = r.ok;
                } catch(e){ reportOk = false; }
                let timelinePdfOk = false;
                try {
                    const r2 = await fetch(resolvePath(paths.timeline_pdf), {method:'HEAD'});
                    timelinePdfOk = r2.ok;
                } catch(e){ timelinePdfOk = false; }

                // Process and display summary
                const summaryEl = document.getElementById('summaryText');
                // Prefer remote records_total endpoint for totals when available
                let remoteInfo = null;
                if(API_BACKEND){
                    try{
                        const rr = await fetch(API_BACKEND.replace(/\/$/, '') + '/api/records_total');
                        if(rr.ok){ remoteInfo = await rr.json(); }
                    }catch(e){ /* ignore */ }
                }

                if(!recordsText && !cacheText && !remoteInfo){
                    summaryEl.textContent = 'No se encontraron archivos records.csv ni country_lookup.csv en las rutas esperadas.';
                    document.getElementById('counts').textContent = '';
                } else {
                    // parse CSVs
                    let records = {headers:[], rows:[]};
                    let cache = {headers:[], rows:[]};
                    if(recordsText) records = parseCSVSimple(recordsText);
                    if(cacheText) cache = parseCSVSimple(cacheText);
                    const totalRecords = remoteInfo && typeof remoteInfo.total_records === 'number' ? remoteInfo.total_records : records.rows.length;
                    const identified = cache.rows.filter(r => (r.country || '').trim() !== '').length;
                    const countriesList = cache.rows.map(r => ({country: r.country || '', iso: r.country_iso2 || ''}));
                    const top = topCounts(cache.rows, 'country', 12);
                    const sourceNote = remoteInfo && remoteInfo.source ? ` (fuente remota: ${remoteInfo.source})` : '';
                    summaryEl.innerHTML = `Registros cargados: <strong>${totalRecords}</strong>${sourceNote}<br>Pa√≠ses identificados en cache: <strong>${identified}</strong>`;
                    const countsEl = document.getElementById('counts');
                    countsEl.innerHTML = `<div class="muted">Si los archivos no existen, verifica que el notebook guard√≥ los resultados en: <code>requerimiento5/data/</code> y <code>outputs/</code></div>`;

                    // Show top countries
                    const topCard = document.getElementById('topCountriesCard');
                    const topContainer = document.getElementById('topCountries');
                    if(top.length){
                        topCard.style.display = 'block';
                        topContainer.innerHTML = '<table><thead><tr><th>Pa√≠s</th><th>Publicaciones</th></tr></thead><tbody>'
                            + top.map(t => `<tr><td>${t[0]}</td><td>${t[1]}</td></tr>`).join('')
                            + '</tbody></table>';
                    } else {
                        topCard.style.display = 'none';
                    }

                    // (Omitido) Vista previa de records.csv eliminada por petici√≥n del usuario
                }

                // Show visuals
                const mapImg = document.getElementById('mapImg');
                const cloudImg = document.getElementById('cloudImg');
                const timelineImg = document.getElementById('timelineImg');
                const mapMsg = document.getElementById('mapMsg');
                const cloudMsg = document.getElementById('cloudMsg');
                const timelineMsg = document.getElementById('timelineMsg');
                const pdfMsg = document.getElementById('pdfMsg');
                const reportLink = document.getElementById('reportLink');
                const timelinePdfLink = document.getElementById('timelinePdfLink');

                if(mapaOk){
                    mapImg.src = resolvePath(paths.mapa) + '?t=' + new Date().getTime();
                    mapImg.style.display = 'block';
                    mapMsg.textContent = '';
                } else {
                    mapImg.style.display = 'none';
                    mapMsg.textContent = 'Mapa no encontrado en: ' + paths.mapa;
                }

                // Prefer the canonical remote image endpoint '/api/image' on the backend.
                const remoteApiImage = API_BACKEND ? API_BACKEND.replace(/\/$/, '') + '/api/image' : null;
                let remote = null;
                if(remoteApiImage){
                    try{ if(await checkImage(remoteApiImage)) remote = remoteApiImage; }catch(e){}
                }
                // If the canonical endpoint isn't available, try other candidates.
                if(!remote){ remote = await findRemoteCloud(); }
                if(remote){
                    cloudImg.src = remote + '?t=' + new Date().getTime();
                    cloudImg.style.display = 'block';
                    cloudMsg.textContent = '(desde backend remoto)';
                } else {
                    cloudImg.style.display = 'none';
                    cloudMsg.textContent = 'Nube remota no disponible en backend';
                }

                if(timelineOk){
                    timelineImg.src = resolvePath(paths.timeline_png) + '?t=' + new Date().getTime();
                    timelineImg.style.display = 'block';
                    timelineMsg.textContent = '';
                } else {
                    // Try remote timeline image on backend before giving up
                    const remoteTimeline = await findRemoteOutput('linea_tiempo_by_source.png');
                    if(remoteTimeline){
                        timelineImg.src = remoteTimeline + '?t=' + new Date().getTime();
                        timelineImg.style.display = 'block';
                        timelineMsg.textContent = '(desde backend remoto)';
                    } else {
                        timelineImg.style.display = 'none';
                        timelineMsg.textContent = 'L√≠nea temporal no encontrada en: ' + paths.timeline_png;
                    }
                }

                if(timelinePdfOk){
                    timelinePdfLink.href = resolvePath(paths.timeline_pdf);
                    timelinePdfLink.style.display = 'inline-block';
                    timelinePdfLink.textContent = 'Abrir l√≠nea temporal (PDF)';
                } else {
                    timelinePdfLink.style.display = 'none';
                }

                if(reportOk){
                    reportLink.href = resolvePath(paths.report);
                    reportLink.style.display = 'inline-block';
                    reportLink.textContent = 'Abrir informe (requerimiento5_report.pdf)';
                    pdfMsg.textContent = '';
                } else {
                    reportLink.style.display = 'none';
                    pdfMsg.textContent = 'Informe PDF no encontrado en: ' + paths.report;
                }

                log('Carga finalizada.');
                showMsg('Carga finalizada.');
                
                // Habilitar bot√≥n de actualizaci√≥n y mostrar info
                document.getElementById('refreshBtn').disabled = false;
                document.getElementById('updateInfo').style.display = 'block';
                document.getElementById('lastUpdate').textContent = new Date().toLocaleString('es-ES');
                document.getElementById('totalRecords').textContent = recordsText ? parseCSVSimple(recordsText).rows.length : '0';
                lastRecordCount = recordsText ? parseCSVSimple(recordsText).rows.length : 0;
                isLoaded = true;
                
            } catch(err){
                log('Error general:', err.message);
                showMsg('Error: ' + err.message);
            } finally {
                btn.disabled = false;
            }
        });
        
        // Funci√≥n para actualizar visualizaciones
        async function refreshVisualizations() {
            if (!isLoaded) return;
            
            log('üîÑ Actualizando visualizaciones...');
            showMsg('Actualizando...');
            
            try {
                // Verificar si hay nuevos registros
                const recordsText = await fetchText(paths.records);
                const records = parseCSVSimple(recordsText);
                const currentCount = records.rows.length;
                
                if (currentCount !== lastRecordCount) {
                    log(`‚ú® Detectados ${currentCount - lastRecordCount} nuevos registros`);
                    lastRecordCount = currentCount;
                    document.getElementById('totalRecords').textContent = currentCount;
                }
                
                // Recargar im√°genes con timestamp para evitar cach√©
                const timestamp = new Date().getTime();
                
                const mapImg = document.getElementById('mapImg');
                const cloudImg = document.getElementById('cloudImg');
                const timelineImg = document.getElementById('timelineImg');
                
                // Verificar y actualizar mapa
                if (await checkImage(paths.mapa)) {
                    mapImg.src = resolvePath(paths.mapa) + '?t=' + timestamp;
                    mapImg.style.display = 'block';
                    document.getElementById('mapMsg').textContent = '';
                    document.getElementById('mapTimestamp').textContent = 'üïê ' + new Date().toLocaleTimeString('es-ES');
                    log('‚úÖ Mapa actualizado');
                }
                
                // Verificar y actualizar nube de palabras ‚Äî preferir el endpoint can√≥nico '/api/image'.
                const remoteApiImage2 = API_BACKEND ? API_BACKEND.replace(/\/$/, '') + '/api/image' : null;
                let remoteNow = null;
                if(remoteApiImage2){ try{ if(await checkImage(remoteApiImage2)) remoteNow = remoteApiImage2; }catch(e){} }
                if(!remoteNow){ remoteNow = await findRemoteCloud(); }
                if(remoteNow){
                    cloudImg.src = remoteNow + '?t=' + timestamp;
                    cloudImg.style.display = 'block';
                    document.getElementById('cloudMsg').textContent = '(desde backend remoto)';
                    document.getElementById('cloudTimestamp').textContent = 'üïê ' + new Date().toLocaleTimeString('es-ES');
                    log('‚úÖ Nube de palabras actualizada (remota)');
                } else {
                    cloudImg.style.display = 'none';
                    document.getElementById('cloudMsg').textContent = 'Nube remota no encontrada';
                }
                
                // Verificar y actualizar l√≠nea temporal
                if (await checkImage(paths.timeline_png)) {
                    timelineImg.src = resolvePath(paths.timeline_png) + '?t=' + timestamp;
                    timelineImg.style.display = 'block';
                    document.getElementById('timelineMsg').textContent = '';
                    document.getElementById('timelineTimestamp').textContent = 'üïê ' + new Date().toLocaleTimeString('es-ES');
                    log('‚úÖ L√≠nea temporal actualizada');
                }
                
                // Actualizar timestamp general
                document.getElementById('lastUpdate').textContent = new Date().toLocaleString('es-ES');
                
                // Recargar datos de pa√≠ses
                const cacheText = await fetchText(paths.cache);
                const cache = parseCSVSimple(cacheText);
                const top = topCounts(cache.rows, 'country', 12);
                
                if(top.length) {
                    const topContainer = document.getElementById('topCountries');
                    topContainer.innerHTML = '<table><thead><tr><th>Pa√≠s</th><th>Publicaciones</th></tr></thead><tbody>'
                        + top.map(t => `<tr><td>${t[0]}</td><td>${t[1]}</td></tr>`).join('')
                        + '</tbody></table>';
                }
                
                log('‚úÖ Actualizaci√≥n completada');
                showMsg('Actualizado: ' + new Date().toLocaleTimeString('es-ES'));
                
            } catch(err) {
                log('‚ùå Error al actualizar:', err.message);
                showMsg('Error en actualizaci√≥n');
            }
        }
        
        // Bot√≥n de actualizaci√≥n manual
        document.getElementById('refreshBtn').addEventListener('click', refreshVisualizations);
        
        // Auto-actualizaci√≥n
        document.getElementById('autoRefresh').addEventListener('change', function() {
            if (this.checked) {
                log('üîÑ Auto-actualizaci√≥n activada (cada 30 segundos)');
                autoRefreshInterval = setInterval(refreshVisualizations, 30000);
                showMsg('Auto-actualizaci√≥n activada');
            } else {
                log('‚è∏Ô∏è Auto-actualizaci√≥n desactivada');
                if (autoRefreshInterval) {
                    clearInterval(autoRefreshInterval);
                    autoRefreshInterval = null;
                }
                showMsg('Auto-actualizaci√≥n desactivada');
            }
        });

        // Upload .bib -> POST /upload_bib
        async function uploadBib(){
            const fileInput = document.getElementById('bibFile');
            const msg = document.getElementById('uploadMsg');
            if(!fileInput || !fileInput.files || fileInput.files.length === 0){
                msg.textContent = 'Selecciona un archivo .bib primero.';
                return;
            }
            const f = fileInput.files[0];
            msg.textContent = 'Subiendo ' + f.name + ' ...';
            const fd = new FormData();
            fd.append('file', f, f.name);
            try{
                const res = await fetch((apiBase || '') + '/api/upload_bib', { method: 'POST', body: fd });
                if(!res.ok) throw new Error('HTTP ' + res.status);
                const j = await res.json();
                log('Archivo subido:', j.filename);
                msg.textContent = 'Archivo subido: ' + j.filename;
                // try to update counts after uploading (in case the server auto-merged)
                await updateCountsFromRecords();
            } catch(e){
                log('Error upload:', e.message);
                msg.textContent = 'Error al subir: ' + e.message;
            }
        }

        // Run wordcloud -> POST /run_wordcloud
        async function runCloud(){
            const msg = document.getElementById('uploadMsg');
            msg.textContent = 'Generando nube...';
            try{
                // If using remote backend, request with a generous timeout parameter
                const runUrl = (apiBase || '') + '/api/run_wordcloud' + (apiBase ? '?timeout=300' : '');
                const res = await fetch(runUrl, { method: 'POST' });
                const j = await res.json();
                log('run_wordcloud result:', JSON.stringify(j));
                if(j.png_url){
                    const cloudImg = document.getElementById('cloudImg');
                    let url = j.png_url;
                    // Normalize to absolute URL if backend base is known
                    if(!url.startsWith('http')){
                        if(url.startsWith('/')){
                            url = API_BACKEND.replace(/\/$/, '') + url;
                        } else if(API_BACKEND){
                            url = API_BACKEND.replace(/\/$/, '') + '/' + url;
                        }
                    }
                    cloudImg.src = url + '?t=' + new Date().getTime();
                    cloudImg.style.display = 'block';
                    document.getElementById('cloudMsg').textContent = '(desde backend remoto)';
                    document.getElementById('cloudTimestamp').textContent = 'üïê ' + new Date().toLocaleTimeString('es-ES');
                    msg.textContent = 'Nube generada.';
                } else {
                    // If no png_url provided, try discovering remote image; do not fall back to local
                    const rc = await findRemoteCloud();
                    if(rc){
                        const cloudImg = document.getElementById('cloudImg');
                        cloudImg.src = rc + '?t=' + new Date().getTime();
                        cloudImg.style.display = 'block';
                        document.getElementById('cloudMsg').textContent = '(desde backend remoto)';
                        document.getElementById('cloudTimestamp').textContent = 'üïê ' + new Date().toLocaleTimeString('es-ES');
                        msg.textContent = 'Nube generada.';
                    } else {
                        msg.textContent = 'No se gener√≥ la imagen de la nube en el backend. Revisa logs.';
                    }
                }
                if(j.stdout) log('stdout:\n' + j.stdout);
                if(j.stderr) log('stderr:\n' + j.stderr);
                // Update counts after running the cloud (script may have merged .bib into records)
                await updateCountsFromRecords();
            } catch(e){
                log('Error al generar nube:', e.message);
                msg.textContent = 'Error al generar nube: ' + e.message;
            }
        }

        document.getElementById('uploadBibBtn').addEventListener('click', uploadBib);
        document.getElementById('runCloudBtn').addEventListener('click', runCloud);
    </script>
</div>
</body>
</html>